<div class="container-divider"></div>
<div class="container">
    <div class="sub-nav">
        {{breadcrumbs}}
        <div class="search-container">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" focusable="false" viewBox="0 0 12 12"
                class="search-icon" aria-hidden="true">
                <circle cx="4.5" cy="4.5" r="4" fill="none" stroke="currentColor" />
                <path stroke="currentColor" stroke-linecap="round" d="M11 11L7.5 7.5" />
            </svg>
            {{search submit=false}}
        </div>
    </div>

    <h1>
        {{t 'submit_a_request'}}
    </h1>

    <div id="main-content" class="form">
        <div id="new-request-form"></div>
    </div>
</div>

<script type="module">
    //Created by Pablo Zarricueta. ZerviZ CX Consultant.
    //https://developer.zendesk.com/api-reference/help_center/help-center-templates/new_request_page/
    import { renderNewRequestForm } from "new-request-form";
    //Mandatory elements prior rendering
    const container = document.getElementById("new-request-form");
    //The settings object has custom properties. The object maps the identifier and value of the variables defined in the theme's manifest.json file. 
    //https://support.zendesk.com/hc/en-us/articles/4408846524954-Customizing-the-Settings-panel-of-the-theme#understanding-the-manifest-json-file
    const settings = {{ json settings }};
    //Object containing information about the new request form: ticket form field, organization field, attachments, etc.
    let request_form_clone = { ...{{ json new_request_form }}};

    //get current user data: user and org tags
    const orgs = window.HelpCenter.user.organizations;
    const userTags = window.HelpCenter.user.tags;

    // Flatten the array of organizations to get only the tags
    const orgTags = orgs.flatMap(org => org.tags);

    //for testing and debugging.
    console.log(userTags);
    console.log(orgs);
    console.log(request_form_clone);
    console.log(request_form_clone.ticket_form_field.value);

    //Set your own ticket field Id. You can use any custom ticket field here.
    const tipo_caso_field_id = '46560480244884'; //first dropdown field
    const tipo_solicitud_field_id = '39445201654164'; //second dropdown field
    const numero_orden_field_id = '39445254638612'; //text field

    //Hide a ticket field dropdown option based on user tag.
    //This is an object.
    const remove_options_by_tag = {
        'user_tag': {
            fieldId: tipo_caso_field_id,          // Ticket Field ID
            options: ['Duda']  // Dropdown Value to remove. Add multiple options if wanted
        }/*, If wanted, you can remove more options from different ticket fields based on user tags.
        'user_tag': {
            fieldId: tipo_solicitud_field_id,          
            options: ['Acceso a cuenta']  
        }*/
    };

    function applyTagBasedOptionFilter(request_form_clone, userTags, rulesByTag) {
        request_form_clone.ticket_fields.forEach(field => {
            // Only custom ticket fields
            if (!field.name.includes("request[custom_fields]")) return;
            // Extract field ID: request[custom_fields][44252325027604] → "44252325027604"
            const match = field.name.match(/\[(\d+)\]$/);
            if (!match) return;
            const fieldId = match[1];
            // Apply rules to the user
            Object.keys(rulesByTag).forEach(tag => {
                if (!userTags.includes(tag)) return; // The user does not have this tag → skip
                const rules = Array.isArray(rulesByTag[tag]) ? rulesByTag[tag] : [rulesByTag[tag]];
                rules.forEach(rule => {
                    if (rule.fieldId !== fieldId) return; // This rule does not apply to this field → skip
                    // Remove the forbidden options from the dropdown
                    field.options = field.options.filter(opt => !rule.options.includes(opt.name));
                });
            });
        });
        return request_form_clone;
    }

    //Change subject text based on a specific ticket form Id
    // Map of ticket_form_id → subject text to display
    const subjectTextByFormId = {
        '46560545585812': 'Demo Custom text',
    };

    function applySubjectTextChange(request_form_clone, subjectTextByFormId) {
        // ticket_form_field is an object (not an array), read its current value directly
        const currentFormId = String(request_form_clone.ticket_form_field.value);
        const newSubject = subjectTextByFormId[currentFormId];

        if (newSubject) {
            // Find the subject field inside ticket_fields and update its value
            request_form_clone.ticket_fields = request_form_clone.ticket_fields.map(field => {
                if (field.name === 'request[subject]') {
                    return { ...field, value: newSubject };
                }
                return field;
            });
        }

        return request_form_clone;
    }


    //Change the description of a specific custom field by its field ID.
    //The 'description' property is the hint/helper text shown below a field in the form.
    const customFieldDescriptionById = {
        '46560480244884': 'Description set by code',  // field ID → new description text
    };

    function applyCustomFieldDescriptionById(request_form_clone, descriptionMap) {
        request_form_clone.ticket_fields = request_form_clone.ticket_fields.map(field => {
            // Only custom ticket fields have names like request[custom_fields][ID]
            const match = field.name && field.name.match(/\[(\d+)\]$/);
            if (!match) return field;

            const fieldId = match[1];
            if (descriptionMap[fieldId] !== undefined) {
                return { ...field, description: descriptionMap[fieldId] };
            }
            return field;
        });
        return request_form_clone;
    }


    const customFieldTextValue = {
        //field ID → text value to display
        '39445254638612': 'Custom text value',
        // more values can be added here
    };

    //Set text value to one or more custom fields by their field ID.
    function applyCustomFieldTextValue(request_form_clone, textValueMap) {
        request_form_clone.ticket_fields = request_form_clone.ticket_fields.map(field => {
            // Only custom ticket fields have names like request[custom_fields][ID]
            const match = field.name && field.name.match(/\[(\d+)\]$/);
            if (!match) return field;

            const fieldId = match[1];
            if (textValueMap[fieldId] !== undefined) {
                return { ...field, value: textValueMap[fieldId] };
            }
            return field;
        });
        return request_form_clone;
    }

    const customFieldDropdownValue = {
        //field ID → dropdown value to display
        '46560480244884': 'demo_reclamo',
        '39445201654164': 'acceso_a_cuenta',
        // more values can be added here
    };

    //Set dropdown value to one or more custom fields by their field ID.
    function applyCustomFieldDropdownValue(request_form_clone, dropdownValueMap) {
        request_form_clone.ticket_fields = request_form_clone.ticket_fields.map(field => {
            // Only custom ticket fields have names like request[custom_fields][ID]
            const match = field.name && field.name.match(/[\[](\d+)[\]]$/);
            if (!match) return field;

            const fieldId = match[1];
            if (dropdownValueMap[fieldId] !== undefined) {
                return { ...field, value: dropdownValueMap[fieldId] };
            }
            return field;
        });
        return request_form_clone;
    }


    //Call to function
    request_form_clone = applyTagBasedOptionFilter(request_form_clone, userTags, remove_options_by_tag);
    request_form_clone = applySubjectTextChange(request_form_clone, subjectTextByFormId);
    request_form_clone = applyCustomFieldDescriptionById(request_form_clone, customFieldDescriptionById);
    request_form_clone = applyCustomFieldTextValue(request_form_clone, customFieldTextValue);
    request_form_clone = applyCustomFieldDropdownValue(request_form_clone, customFieldDropdownValue);

    //--------------------
    //Render the form
    //-------------------
    const props = {
        requestForm: request_form_clone, // Use form Clone
        newRequestPath: {{ json (page_path 'new_request')}},
    parentId: { {json parent.id } },
    parentIdPath: { {json parent.url } },
    locale: { {json help_center.locale } },
    baseLocale: { {json help_center.base_locale } },
    hasAtMentions: { {json help_center.at_mentions_enabled } },
    userRole: { {json user.role } },
    userId: { {json user.id } },
    brandId: { {json brand.id } },
    organizations: { {json user.organizations } },
    wysiwyg: true,
        answerBotModal: {
        answerBot: { {json answer_bot } },
        hasRequestManagement: { {json help_center.request_management_enabled } },
        isSignedIn: { {json signed_in } },
        helpCenterPath: { { json(page_path 'help_center') } },
        requestsPath: { { json(page_path 'requests') } },
        requestPath: { { json(page_path 'request' id = answer_bot.request_id) } }
    },
};

    renderNewRequestForm(settings, props, container);

    //Hide the ticket form selector (ticket_form_field) from the DOM.
    //This field is not part of ticket_fields, so it must be hidden via DOM after render.

    /* DISABLED
    const formSelectorObserver = new MutationObserver((mutations, obs) => {
        const formSelectorField = container.querySelector('[data-garden-id="dropdowns.combobox.field"]');
        if (formSelectorField) {
            formSelectorField.style.display = 'none';
            obs.disconnect();
        }
    });
    formSelectorObserver.observe(container, { childList: true, subtree: true });*/

    //Hide a custom ticket field from the DOM.
    //Custom fields render a hidden input with name="request[custom_fields][FIELD_ID]".
    //We find that input in the DOM and hide its closest field wrapper.

    /* DISABLED
    const customFieldObserver = new MutationObserver((mutations, obs) => {
        const fieldInput = container.querySelector(
            `input[name="request[custom_fields][${tipo_solicitud_field_id}]"]`
        );
        if (fieldInput) {
            const fieldWrapper = fieldInput.closest('[data-garden-id="dropdowns.combobox.field"]');
            if (fieldWrapper) fieldWrapper.style.display = 'none';
            obs.disconnect();
        }
    });
    customFieldObserver.observe(container, { childList: true, subtree: true }); */

    //Block ticket submission if a required attachment is missing,
    //based on the value of a specific dropdown field.
    //
    //How it works:
    //  - A MutationObserver waits for the Submit button to appear in the DOM.
    //  - A click listener (capture phase) intercepts the click BEFORE the form processes it.
    //  - It reads the hidden input for the trigger field to get the currently selected value.
    //  - It checks if any file has been attached (Zendesk adds hidden inputs for each upload).
    //  - If the rule applies and no file is found, it cancels the submission and shows a message.
    //
    //Configuration: add as many rules as needed to the array below.

    const attachmentRequiredRules = [
        {
            fieldId: tipo_caso_field_id,          // ID of the dropdown field to evaluate
            triggerValues: ['acceso_a_cuenta'],    // Value(s) that require an attachment
            alertMessage: 'Debes adjuntar un archivo antes de enviar el formulario para este tipo de caso.',
        },
        // Add more rules here if needed:
        // {
        //     fieldId: 'ANOTHER_FIELD_ID',
        //     triggerValues: ['some_value', 'another_value'],
        //     alertMessage: 'xx',
        // },
    ];

    function applyAttachmentValidation(container, rules) {

        // Helper: show or remove an inline error message near the submit button
        function showAttachmentError(form, message) {
            const existingError = form.querySelector('#attachment-required-error');
            if (existingError) return; // already showing
            const errorEl = document.createElement('p');
            errorEl.id = 'attachment-required-error';
            errorEl.style.cssText = 'color:#c72a1c; font-weight:600; margin-top:8px;';
            errorEl.textContent = message;
            const submitBtn = form.querySelector('button[type="submit"]');
            if (submitBtn) submitBtn.insertAdjacentElement('afterend', errorEl);
        }

        function clearAttachmentError(form) {
            const el = form.querySelector('#attachment-required-error');
            if (el) el.remove();
        }

        const submitObserver = new MutationObserver(() => {
            const submitBtn = container.querySelector('button[type="submit"]');
            if (!submitBtn) return;

            submitObserver.disconnect(); // Found it — stop observing

            submitBtn.addEventListener('click', function (e) {
                const form = container.querySelector('form');
                if (!form) return;

                // Check every rule
                for (const rule of rules) {
                    // Read the hidden input that holds the current dropdown value
                    const triggerInput = form.querySelector(
                        `input[name="request[custom_fields][${rule.fieldId}]"]`
                    );
                    if (!triggerInput) continue;

                    const currentValue = triggerInput.value;
                    if (!rule.triggerValues.includes(currentValue)) {
                        clearAttachmentError(form);
                        continue; // Rule does not apply for this value → skip
                    }

                    // Check if at least one file has been attached.
                    // Zendesk renders a hidden input per uploaded token: name="request[attachments][]"
                    const attachments = form.querySelectorAll('input[name="request[attachments][]"]');
                    const hasAttachment = attachments.length > 0;

                    if (!hasAttachment) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        showAttachmentError(form, rule.alertMessage);
                        return; // Stop checking further rules
                    }

                    clearAttachmentError(form);
                }
            }, true); // capture: true → intercepts before the form's own handler
        });

        submitObserver.observe(container, { childList: true, subtree: true });
    }

    applyAttachmentValidation(container, attachmentRequiredRules);


</script>
